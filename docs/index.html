<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SFCompute Pricing</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{--bg:#0b0c10;--card:#151720;--muted:#9aa0aa;--text:#e8eaed;--accent:#6aa9ff}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1150px;margin:24px auto;padding:0 16px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
    h1{font-size:20px;margin:0}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(0,0,0,.2);margin-bottom:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:end}
    label{display:block;color:var(--muted);font-size:12px;margin-bottom:4px}
    select{background:#0e1117;border:1px solid #2a2f3a;color:var(--text);border-radius:10px;padding:8px 10px}
    input[type="range"]{width:180px}
    .table-wrap{overflow:auto;border-radius:12px;border:1px solid #2a2f3a;margin-top:12px}
    table{border-collapse:separate;border-spacing:0;width:100%;min-width:560px}
    th,td{padding:8px 10px;border-bottom:1px solid #242a34}
    th{position:sticky;top:0;background:#10131a;color:#cfd3da;font-weight:600}
    tr:hover td{background:#121722}
    .mono{font-variant-numeric:tabular-nums}
    .muted{color:var(--muted)}
    .kpi{display:grid;grid-template-columns:repeat(4,minmax(120px,1fr));gap:12px;margin-top:8px}
    .kpi div{background:#10131a;border:1px solid #222a35;border-radius:12px;padding:10px}
    .kpi strong{font-size:16px}
    .chart-wrap{position:relative;height:250px;width:100%;}
    @media (max-width: 900px){ .chart-wrap{ height:220px; } }
    @media (max-width: 520px){ .chart-wrap{ height:200px; } }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>SFCompute Pricing</h1>
    <div class="muted">Data: <code>data/sfcompute_latest.csv</code> & <code>data/sfcompute_history.csv</code></div>
  </header>

  <!-- LATEST -->
  <div class="card">
    <div class="row" style="margin-bottom:8px">
      <div>
        <label for="gpu">GPU</label>
        <select id="gpu"></select>
      </div>
      <div>
        <label for="duration">Duration</label>
        <select id="duration"></select>
      </div>
      <div>
        <label for="count">GPU Count</label>
        <select id="count"></select>
      </div>
      <div style="margin-left:auto">
        <span class="muted" id="lastRefresh">loading…</span>
      </div>
    </div>

    <div class="kpi">
      <div><span class="muted">Latest snapshot (UTC)</span><br><strong id="kpiDate">—</strong></div>
      <div><span class="muted">Selected price</span><br><strong class="mono" id="kpiPrice">—</strong></div>
      <div><span class="muted">Min across counts</span><br><strong class="mono" id="kpiMin">—</strong></div>
      <div><span class="muted">Max across counts</span><br><strong class="mono" id="kpiMax">—</strong></div>
    </div>

    <div class="table-wrap">
      <table id="latestTable"></table>
    </div>
  </div>

  <!-- HISTORY + FORECAST -->
  <div class="card">
    <div class="row" style="margin-bottom:8px">
      <div>
        <label for="day">Day (history)</label>
        <select id="day"></select>
      </div>
      <div style="margin-left:auto">
        <label><input type="checkbox" id="showForecast"> Show forecast</label>
      </div>
    </div>
    <div class="chart-wrap">
      <canvas id="histChart"></canvas>
    </div>
    <div id="modelBadge" class="muted" style="margin-top:6px;font-size:12px">—</div>
  </div>

  <!-- ALERTS (compact, grouped) -->
  <div class="card" id="alertsCard">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0;font-size:16px">Price Alerts</h3>
      <div id="alertsBadge" class="muted">—</div>
    </div>
    <div id="alertsGroups" class="muted" style="margin-top:8px">Loading…</div>
  </div>

  <!-- ROI CALCULATOR (interactive) -->
  <div class="card" id="roiCard">
    <h3 style="margin:0 0 8px;font-size:16px">ROI / Budget Calculator</h3>
    <div class="row" style="gap:10px;align-items:flex-end">
      <div><label for="roiGpu">GPU</label><select id="roiGpu"></select></div>
      <div><label for="roiDur">Duration</label><select id="roiDur"></select></div>
      <div><label for="roiCount">GPU Count</label><select id="roiCount"></select></div>
      <div style="min-width:180px">
        <label for="roiUtil">Utilisation: <span id="roiUtilVal">75%</span></label>
        <input id="roiUtil" type="range" min="10" max="100" step="5" value="75">
      </div>
      <div style="margin-left:auto;text-align:right">
        <div class="muted">Monthly Cost</div>
        <div id="roiCost" class="mono" style="font-size:20px">$—</div>
        <div id="roiUnit" class="muted" style="font-size:12px">—</div>
      </div>
    </div>

    <div class="table-wrap" style="margin-top:10px">
      <table id="roiQuick"></table>
    </div>
  </div>
</div>

<script>
  // CSV paths (we are inside docs/, so use 'data/...'):
  const LATEST_PATH   = 'data/sfcompute_latest.csv?ts=' + Date.now();
  const HISTORY_PATH  = 'data/sfcompute_history.csv?ts=' + Date.now();
  const FORECAST_PATH = 'data/sfcompute_forecast.csv?ts=' + Date.now();
  const METRICS_PATH  = 'data/sfcompute_metrics.csv?ts=' + Date.now();
  const ALERTS_PATH   = 'data/alerts.csv?ts=' + Date.now();
  const ROI_PATH      = 'data/roi_catalog.csv?ts=' + Date.now();

  const DURATIONS = ["1 hour","1 day","1 week","1 month"];
  const FALLBACK_COUNTS = [8,16,32,64,128,256];
  const HOURS_PER_MONTH = 730;

  let LATEST=[], HISTORY=[], FORECAST=[], METRICS=[], ALERTS=[], ROI=[], chart;

  // --- utils ---
  function csv(url){
    return new Promise((res, rej) => {
      Papa.parse(url, {download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
        complete: r => res(r.data), error: err => rej(err)});
    });
  }
  const uniq = a => Array.from(new Set(a));
  const fmt  = x => (x==null || Number.isNaN(x)) ? '—' : `$${Number(x).toFixed(2)}`;
  const dayOf = ts => (ts||'').slice(0,10);

  function coerceRow(r){
    r.gpu_type = String(r.gpu_type || r.gpu || '').trim();
    r.duration = String(r.duration || '').trim();
    r.gpu_count = Number(r.gpu_count);
    if (typeof r.usd_per_gpu_hr === 'string'){
      const m = r.usd_per_gpu_hr.match(/(\d+(\.\d+)?)/);
      r.usd_per_gpu_hr = m ? Number(m[1]) : null;
    }
    if (r.usd_per_gpu_hr === '' || r.usd_per_gpu_hr === 'None') r.usd_per_gpu_hr = null;
    r.ts_utc = String(r.ts_utc || r.timestamp || '');
    return r;
  }

  function buildPivot(rows){
    const m = new Map();
    let newest = '';
    for(const r of rows){
      const k = `${r.duration}|${r.gpu_count}`;
      m.set(k, r.usd_per_gpu_hr);
      if (String(r.ts_utc) > newest) newest = String(r.ts_utc);
    }
    return {pivot:m, newest};
  }

  function renderLatest(gpuSel, durationSel, countSel){
    const rows = LATEST.filter(r => r.gpu_type === gpuSel);
    const counts = rows.length ? uniq(rows.map(r => r.gpu_count)).sort((a,b)=>a-b) : FALLBACK_COUNTS.slice();
    const {pivot, newest} = buildPivot(rows);

    document.getElementById('count').innerHTML = counts.map(v=>`<option>${v}</option>`).join('');
    if (!counts.includes(Number(countSel))){
      countSel = counts[0];
      document.getElementById('count').value = countSel;
    }

    const tbl = document.getElementById('latestTable');
    let html = '<thead><tr><th>Duration</th>' + counts.map(c=>`<th class="mono">${c}</th>`).join('') + '</tr></thead><tbody>';
    for (const d of DURATIONS){
      html += `<tr><td>${d}</td>`;
      for (const c of counts){
        html += `<td class="mono">${fmt(pivot.get(`${d}|${c}`))}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody>';
    tbl.innerHTML = html;

    const selVal = pivot.get(`${durationSel}|${Number(countSel)}`);
    const rowVals = counts.map(c => pivot.get(`${durationSel}|${c}`)).filter(v => v != null);
    const kMin = rowVals.length ? Math.min(...rowVals) : null;
    const kMax = rowVals.length ? Math.max(...rowVals) : null;
    document.getElementById('kpiDate').textContent  = newest || '—';
    document.getElementById('kpiPrice').textContent = fmt(selVal);
    document.getElementById('kpiMin').textContent   = fmt(kMin);
    document.getElementById('kpiMax').textContent   = fmt(kMax);
  }

  function drawHistoryChart(labels, y, title){
    const ctx = document.getElementById('histChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label: title, data: y, tension:.2, pointRadius:0 }] },
      options: {
        responsive:true, maintainAspectRatio:false,
        scales:{ x:{ ticks:{ maxRotation:0, autoSkip:true } }, y:{ beginAtZero:false } },
        plugins:{ legend:{ labels:{ color:'#cfd3da' } } }
      }
    });
  }

  function renderHistory(gpuSel, durationSel, countSel){
    const rows = HISTORY.filter(r =>
      r.gpu_type === gpuSel && r.duration === durationSel && r.gpu_count === Number(countSel) && r.usd_per_gpu_hr != null
    ).sort((a,b)=> String(a.ts_utc).localeCompare(String(b.ts_utc)));

    const days = ['All days', ...uniq(rows.map(r => dayOf(r.ts_utc)))];
    const daySel = document.getElementById('day');
    if (!daySel.options.length){
      daySel.innerHTML = days.map(d=>`<option>${d}</option>`).join('');
    } else {
      const cur = daySel.value;
      daySel.innerHTML = days.map(d=>`<option ${d===cur?'selected':''}>${d}</option>`).join('');
    }

    let filtered = rows;
    if (daySel.value && daySel.value !== 'All days'){
      filtered = rows.filter(r => dayOf(r.ts_utc) === daySel.value);
    }

    const labels = filtered.map(r => r.ts_utc);
    const y = filtered.map(r => r.usd_per_gpu_hr);
    drawHistoryChart(labels, y, `${gpuSel} · ${durationSel} · ${countSel} GPUs`);

    // Forecast overlay
    const showFc = document.getElementById('showForecast').checked;
    if (showFc && FORECAST.length){
      const fc = FORECAST.filter(r =>
        r.gpu_type===gpuSel && r.duration===durationSel && Number(r.gpu_count)===Number(countSel)
      ).sort((a,b)=> String(a.ds||a.ts_utc).localeCompare(String(b.ds||b.ts_utc)));
      if (fc.length){
        const yhat = fc.map(r=> Number(r.yhat));
        chart.data.datasets.push({ label:"Forecast", data:yhat, borderColor:"#6aa9ff", borderDash:[5,4], tension:.2, pointRadius:0 });
        // simple CI band using yhat as filled area
        chart.data.datasets.push({ label:"Forecast CI", data:yhat, backgroundColor:"rgba(106,169,255,0.15)", borderColor:"transparent", fill:true, pointRadius:0, tension:.2 });
        chart.update();
      }
    }

    // Model badge (if metrics present)
    const m = METRICS.find(r => r.gpu_type===gpuSel && r.duration===durationSel && Number(r.gpu_count)===Number(countSel));
    const badge = document.getElementById('modelBadge');
    if (m){
      const skill = (Number(m.skill)*100).toFixed(1);
      const smape = Number(m.smape).toFixed(1);
      badge.textContent = `Model skill vs naive: ${skill}% · SMAPE: ${smape}%`;
    } else {
      badge.textContent = '—';
    }

    daySel.onchange = () => renderHistory(gpuSel, durationSel, countSel);
  }

  function updateAll(){
    const gpuSel = document.getElementById('gpu').value;
    const durSel = document.getElementById('duration').value;
    const cntSel = document.getElementById('count').value;
    renderLatest(gpuSel, durSel, cntSel);
    renderHistory(gpuSel, durSel, cntSel);
  }

  // ---------- Alerts (grouped, compact) ----------
  function renderAlerts() {
    const badge = document.getElementById('alertsBadge');
    const box   = document.getElementById('alertsGroups');

    if (!ALERTS.length){
      badge.textContent = '0 alerts';
      box.textContent = '✅ No active alerts';
      return;
    }

    const rows = ALERTS.map(r => ({
      gpu_type: String(r.gpu_type),
      duration: String(r.duration),
      gpu_count: Number(r.gpu_count),
      price: Number(r.usd_per_gpu_hr),
      bench: Number(r.benchmark_price),
      delta: Number(r.delta_pct) // negative = cheaper than benchmark
    })).sort((a,b)=> a.delta - b.delta);

    const groups = {};
    for (const r of rows){
      groups[r.gpu_type] ||= {};
      groups[r.gpu_type][r.duration] ||= [];
      groups[r.gpu_type][r.duration].push(r);
    }

    badge.textContent = `${rows.length} alert${rows.length!==1?'s':''}`;

    const top3 = rows.slice(0,3);
    const fmtLine = r =>
      `${r.gpu_type} · ${r.duration} · ${r.gpu_count} ⟶ $${r.price.toFixed(2)} (vs ${r.bench.toFixed(2)}, ${(r.delta*100).toFixed(1)}%)`;

    let html = top3.map(r => `⚠️ ${fmtLine(r)}`).join('<br>');
    if (rows.length > 3){
      html += `<div style="margin-top:8px"><a href="#" id="alertsToggle">Show all (${rows.length-3} more)</a></div>`;
    }
    box.innerHTML = html;

    const toggle = document.getElementById('alertsToggle');
    if (toggle){
      toggle.onclick = (e) => {
        e.preventDefault();
        let full = '';
        for (const gpu of Object.keys(groups)){
          full += `<div style="margin-top:8px"><strong>${gpu}</strong></div>`;
          for (const dur of Object.keys(groups[gpu])){
            const list = groups[gpu][dur]
              .sort((a,b)=>a.delta-b.delta)
              .map(r => `• ${r.gpu_count} ⟶ $${r.price.toFixed(2)} (vs ${r.bench.toFixed(2)}, ${(r.delta*100).toFixed(1)}%)`)
              .join('<br>');
            full += `<div class="muted" style="margin-left:10px"><em>${dur}</em><br>${list}</div>`;
          }
        }
        box.innerHTML = full;
      };
    }
  }

  // ---------- ROI / Budget (interactive) ----------
  function initRoiControls(){
    const gpuSel  = document.getElementById('roiGpu');
    const durSel  = document.getElementById('roiDur');
    const cntSel  = document.getElementById('roiCount');

    const gpus = Array.from(new Set(LATEST.map(r=>String(r.gpu_type)))).sort();
    const durs = ["1 hour","1 day","1 week","1 month"];
    const counts = Array.from(new Set(LATEST.map(r=>Number(r.gpu_count)))).sort((a,b)=>a-b);

    gpuSel.innerHTML = gpus.map(x=>`<option>${x}</option>`).join('');
    durSel.innerHTML = durs.map(x=>`<option>${x}</option>`).join('');
    cntSel.innerHTML = counts.map(x=>`<option>${x}</option>`).join('');

    updateRoi();
    [gpuSel,durSel,cntSel, document.getElementById('roiUtil')].forEach(el => el.oninput = updateRoi);
  }

  function findLatestPrice(gpu, dur, count){
    const r = LATEST.find(x => String(x.gpu_type)===gpu && String(x.duration)===dur && Number(x.gpu_count)===Number(count));
    return r ? Number(r.usd_per_gpu_hr) : NaN;
  }

  function updateRoi(){
    const gpu = document.getElementById('roiGpu').value;
    const dur = document.getElementById('roiDur').value;
    const cnt = Number(document.getElementById('roiCount').value);
    const utilPct = Number(document.getElementById('roiUtil').value);
    document.getElementById('roiUtilVal').textContent = `${utilPct}%`;

    const price = findLatestPrice(gpu, dur, cnt);
    const util = utilPct/100;
    const cost = isFinite(price) ? price * HOURS_PER_MONTH * cnt * util : NaN;

    document.getElementById('roiCost').textContent = isFinite(cost) ? `$${cost.toFixed(0)}` : '$—';
    document.getElementById('roiUnit').textContent = isFinite(price)
      ? `${gpu} • ${dur} • ${cnt} GPUs at $${price.toFixed(2)}/hr`
      : '—';

    // quick presets table (for selected GPU+duration)
    const counts = [8,16,32,64,128,256].filter(n => isFinite(findLatestPrice(gpu, dur, n)));
    const presets = [50,75,100];

    let html = '<thead><tr><th>Count</th>' + presets.map(p=>`<th>${p}%</th>`).join('') + '</tr></thead><tbody>';
    for (const n of counts){
      const p = findLatestPrice(gpu, dur, n);
      html += `<tr><td>${n}</td>` + presets.map(pp => {
        const c = p*HOURS_PER_MONTH*n*(pp/100);
        return `<td class="mono">$${c.toFixed(0)}</td>`;
      }).join('') + '</tr>';
    }
    html += '</tbody>';
    document.getElementById('roiQuick').innerHTML = html;
  }

  // ---------- load extras (forecast/metrics/alerts/roi) ----------
  async function loadExtras(){
    try{
      [FORECAST, METRICS, ALERTS, ROI] = await Promise.all([
        csv(FORECAST_PATH).catch(()=>[]),
        csv(METRICS_PATH).catch(()=>[]),
        csv(ALERTS_PATH).catch(()=>[]),
        csv(ROI_PATH).catch(()=>[])
      ]);

      // If ROI CSV exists, we still prefer interactive calc from LATEST;
      // ROI CSV is only used if you want to render a static table elsewhere.

      // Render Alerts after load
      renderAlerts();
    }catch(e){ console.warn("extras failed",e); }
  }

  // ---------- main boot ----------
  async function main(){
    try{
      document.getElementById('lastRefresh').textContent = 'loading…';
      const [latestRows, histRows] = await Promise.all([
        csv(LATEST_PATH).catch(()=>[]),
        csv(HISTORY_PATH).catch(()=>[])
      ]);
      LATEST  = latestRows.map(coerceRow);
      HISTORY = histRows.map(coerceRow);

      // Fallback: derive latest from history
      if (!LATEST.length && HISTORY.length){
        const byKey = new Map();
        for (const r of HISTORY){
          const k = `${r.gpu_type}|${r.duration}|${r.gpu_count}`;
          const prev = byKey.get(k);
          if (!prev || String(r.ts_utc) > String(prev.ts_utc)) byKey.set(k, r);
        }
        LATEST = [...byKey.values()];
      }

      if (!LATEST.length && !HISTORY.length){
        document.getElementById('lastRefresh').textContent = 'No data found. Check docs/data/*.csv';
        return;
      }

      const gpus = uniq(LATEST.map(r=>r.gpu_type)).sort();
      const counts = uniq(LATEST.map(r=>r.gpu_count)).sort((a,b)=>a-b);
      document.getElementById('gpu').innerHTML = gpus.map(v=>`<option>${v}</option>`).join('');
      document.getElementById('duration').innerHTML = ["1 hour","1 day","1 week","1 month"].map(v=>`<option>${v}</option>`).join('');
      document.getElementById('count').innerHTML = counts.map(v=>`<option>${v}</option>`).join('');

      document.getElementById('lastRefresh').textContent = 'loaded ' + new Date().toISOString().slice(0,19) + 'Z';

      updateAll();
      ['gpu','duration','count','showForecast'].forEach(id => document.getElementById(id).addEventListener('change', updateAll));

      // Init ROI controls now that LATEST is in memory
      initRoiControls();
    }catch(e){
      console.error(e);
      document.getElementById('lastRefresh').textContent = 'failed to load';
    }
  }

  // Boot sequence
  (async () => {
    await main();
    await loadExtras();
  })();
</script>
</body>
</html>


