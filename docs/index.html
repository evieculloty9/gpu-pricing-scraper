<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SFCompute Pricing</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{--bg:#0b0c10;--card:#151720;--muted:#9aa0aa;--text:#e8eaed;--accent:#6aa9ff}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1150px;margin:24px auto;padding:0 16px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
    h1{font-size:20px;margin:0}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(0,0,0,.2);margin-bottom:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:end}
    label{display:block;color:var(--muted);font-size:12px;margin-bottom:4px}
    select{background:#0e1117;border:1px solid #2a2f3a;color:var(--text);border-radius:10px;padding:8px 10px}
    .table-wrap{overflow:auto;border-radius:12px;border:1px solid #2a2f3a;margin-top:12px}
    table{border-collapse:separate;border-spacing:0;width:100%;min-width:560px}
    th,td{padding:8px 10px;border-bottom:1px solid #242a34}
    th{position:sticky;top:0;background:#10131a;color:#cfd3da;font-weight:600}
    tr:hover td{background:#121722}
    .mono{font-variant-numeric:tabular-nums}
    .muted{color:var(--muted)}
    .kpi{display:grid;grid-template-columns:repeat(4,minmax(120px,1fr));gap:12px;margin-top:8px}
    .kpi div{background:#10131a;border:1px solid #222a35;border-radius:12px;padding:10px}
    .kpi strong{font-size:16px}
    .chart-wrap{position:relative;height:250px;width:100%;}
    @media (max-width: 900px){ .chart-wrap{ height:220px; } }
    @media (max-width: 520px){ .chart-wrap{ height:200px; } }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>SFCompute Pricing</h1>
    <div class="muted">Data: <code>data/sfcompute_latest.csv</code> & <code>data/sfcompute_history.csv</code></div>
  </header>

  <!-- LATEST -->
  <div class="card">
    <div class="row" style="margin-bottom:8px">
      <div>
        <label for="gpu">GPU</label>
        <select id="gpu"></select>
      </div>
      <div>
        <label for="duration">Duration</label>
        <select id="duration"></select>
      </div>
      <div>
        <label for="count">GPU Count</label>
        <select id="count"></select>
      </div>
      <div style="margin-left:auto">
        <span class="muted" id="lastRefresh">loading…</span>
      </div>
    </div>

    <div class="kpi">
      <div><span class="muted">Latest snapshot (UTC)</span><br><strong id="kpiDate">—</strong></div>
      <div><span class="muted">Selected price</span><br><strong class="mono" id="kpiPrice">—</strong></div>
      <div><span class="muted">Min across counts</span><br><strong class="mono" id="kpiMin">—</strong></div>
      <div><span class="muted">Max across counts</span><br><strong class="mono" id="kpiMax">—</strong></div>
    </div>

    <div class="table-wrap">
      <table id="latestTable"></table>
    </div>
  </div>

  <!-- HISTORY + FORECAST -->
  <div class="card">
    <div class="row" style="margin-bottom:8px">
      <div>
        <label for="day">Day (history)</label>
        <select id="day"></select>
      </div>
      <div style="margin-left:auto">
        <label><input type="checkbox" id="showForecast"> Show forecast</label>
      </div>
    </div>
    <div class="chart-wrap">
      <canvas id="histChart"></canvas>
    </div>
    <div id="modelBadge" class="muted" style="margin-top:6px;font-size:12px">—</div>
  </div>

  <!-- ALERTS -->
  <div class="card">
    <h3 style="margin-top:0;font-size:16px">Price Alerts</h3>
    <div id="alertsBox" class="muted">Loading…</div>
  </div>

  <!-- ROI -->
  <div class="card">
    <h3 style="margin-top:0;font-size:16px">ROI / Budget Calculator</h3>
    <div class="table-wrap">
      <table id="roiTable"></table>
    </div>
  </div>
</div>

<script>
  // CSV paths (we are inside docs/, so use 'data/...'):
  const LATEST_PATH   = 'data/sfcompute_latest.csv?ts=' + Date.now();
  const HISTORY_PATH  = 'data/sfcompute_history.csv?ts=' + Date.now();
  const FORECAST_PATH = 'data/sfcompute_forecast.csv?ts=' + Date.now();
  const METRICS_PATH  = 'data/sfcompute_metrics.csv?ts=' + Date.now();
  const ALERTS_PATH   = 'data/alerts.csv?ts=' + Date.now();
  const ROI_PATH      = 'data/roi_catalog.csv?ts=' + Date.now();

  const DURATIONS = ["1 hour","1 day","1 week","1 month"];
  const FALLBACK_COUNTS = [8,16,32,64,128,256];

  let LATEST=[], HISTORY=[], FORECAST=[], METRICS=[], ALERTS=[], ROI=[], chart;

  // --- utils ---
  function csv(url){
    return new Promise((res, rej) => {
      Papa.parse(url, {download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
        complete: r => res(r.data), error: err => rej(err)});
    });
  }
  const uniq = a => Array.from(new Set(a));
  const fmt  = x => (x==null || Number.isNaN(x)) ? '—' : `$${Number(x).toFixed(2)}`;
  const dayOf = ts => (ts||'').slice(0,10);

  function coerceRow(r){
    r.gpu_type = String(r.gpu_type || r.gpu || '').trim();
    r.duration = String(r.duration || '').trim();
    r.gpu_count = Number(r.gpu_count);
    if (typeof r.usd_per_gpu_hr === 'string'){
      const m = r.usd_per_gpu_hr.match(/(\d+(\.\d+)?)/);
      r.usd_per_gpu_hr = m ? Number(m[1]) : null;
    }
    if (r.usd_per_gpu_hr === '' || r.usd_per_gpu_hr === 'None') r.usd_per_gpu_hr = null;
    r.ts_utc = String(r.ts_utc || r.timestamp || '');
    return r;
  }

  function buildPivot(rows){
    const m = new Map();
    let newest = '';
    for(const r of rows){
      const k = `${r.duration}|${r.gpu_count}`;
      m.set(k, r.usd_per_gpu_hr);
      if (String(r.ts_utc) > newest) newest = String(r.ts_utc);
    }
    return {pivot:m, newest};
  }

  function renderLatest(gpuSel, durationSel, countSel){
    const rows = LATEST.filter(r => r.gpu_type === gpuSel);
    const counts = rows.length ? uniq(rows.map(r => r.gpu_count)).sort((a,b)=>a-b) : FALLBACK_COUNTS.slice();
    const {pivot, newest} = buildPivot(rows);

    document.getElementById('count').innerHTML = counts.map(v=>`<option>${v}</option>`).join('');
    if (!counts.includes(Number(countSel))){
      countSel = counts[0];
      document.getElementById('count').value = countSel;
    }

    const tbl = document.getElementById('latestTable');
    let html = '<thead><tr><th>Duration</th>' + counts.map(c=>`<th class="mono">${c}</th>`).join('') + '</tr></thead><tbody>';
    for (const d of DURATIONS){
      html += `<tr><td>${d}</td>`;
      for (const c of counts){
        html += `<td class="mono">${fmt(pivot.get(`${d}|${c}`))}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody>';
    tbl.innerHTML = html;

    const selVal = pivot.get(`${durationSel}|${Number(countSel)}`);
    const rowVals = counts.map(c => pivot.get(`${durationSel}|${c}`)).filter(v => v != null);
    const kMin = rowVals.length ? Math.min(...rowVals) : null;
    const kMax = rowVals.length ? Math.max(...rowVals) : null;
    document.getElementById('kpiDate').textContent  = newest || '—';
    document.getElementById('kpiPrice').textContent = fmt(selVal);
    document.getElementById('kpiMin').textContent   = fmt(kMin);
    document.getElementById('kpiMax').textContent   = fmt(kMax);
  }

  function drawHistoryChart(labels, y, title){
    const ctx = document.getElementById('histChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label: title, data: y, tension:.2, pointRadius:0 }] },
      options: {
        responsive:true, maintainAspectRatio:false,
        scales:{ x:{ ticks:{ maxRotation:0, autoSkip:true } }, y:{ beginAtZero:false } },
        plugins:{ legend:{ labels:{ color:'#cfd3da' } } }
      }
    });
  }

  function renderHistory(gpuSel, durationSel, countSel){
    const rows = HISTORY.filter(r =>
      r.gpu_type === gpuSel && r.duration === durationSel && r.gpu_count === Number(countSel) && r.usd_per_gpu_hr != null
    ).sort((a,b)=> String(a.ts_utc).localeCompare(String(b.ts_utc)));

    const days = ['All days', ...uniq(rows.map(r => dayOf(r.ts_utc)))];
    const daySel = document.getElementById('day');
    if (!daySel.options.length){
      daySel.innerHTML = days.map(d=>`<option>${d}</option>`).join('');
    } else {
      const cur = daySel.value;
      daySel.innerHTML = days.map(d=>`<option ${d===cur?'selected':''}>${d}</option>`).join('');
    }

    let filtered = rows;
    if (daySel.value && daySel.value !== 'All days'){
      filtered = rows.filter(r => dayOf(r.ts_utc) === daySel.value);
    }

    const labels = filtered.map(r => r.ts_utc);
    const y = filtered.map(r => r.usd_per_gpu_hr);
    drawHistoryChart(labels, y, `${gpuSel} · ${durationSel} · ${countSel} GPUs`);

    // Forecast overlay
    const showFc = document.getElementById('showForecast').checked;
    if (showFc && FORECAST.length){
      const fc = FORECAST.filter(r =>
        r.gpu_type===gpuSel && r.duration===durationSel && Number(r.gpu_count)===Number(countSel)
      ).sort((a,b)=> String(a.ds||a.ts_utc).localeCompare(String(b.ds||b.ts_utc)));
      if (fc.length){
        const yhat = fc.map(r=> Number(r.yhat));
        chart.data.datasets.push({ label:"Forecast", data:yhat, borderColor:"#6aa9ff", borderDash:[5,4], tension:.2, pointRadius:0 });
        // CI band (use yhat as base so Chart.js can fill)
        chart.data.datasets.push({ label:"Forecast CI", data:yhat, backgroundColor:"rgba(106,169,255,0.15)", borderColor:"transparent", fill:true, pointRadius:0, tension:.2 });
        chart.update();
      }
    }

    // Model badge (if metrics present)
    const m = METRICS.find(r => r.gpu_type===gpuSel && r.duration===durationSel && Number(r.gpu_count)===Number(countSel));
    const badge = document.getElementById('modelBadge');
    if (m){
      const skill = (Number(m.skill)*100).toFixed(1);
      const smape = Number(m.smape).toFixed(1);
      badge.textContent = `Model skill vs naive: ${skill}% · SMAPE: ${smape}%`;
    } else {
      badge.textContent = '—';
    }

    daySel.onchange = () => renderHistory(gpuSel, durationSel, countSel);
  }

  function updateAll(){
    const gpuSel = document.getElementById('gpu').value;
    const durSel = document.getElementById('duration').value;
    const cntSel = document.getElementById('count').value;
    renderLatest(gpuSel, durSel, cntSel);
    renderHistory(gpuSel, durSel, cntSel);
  }

  async function loadExtras(){
    try{
      [FORECAST, METRICS, ALERTS, ROI] = await Promise.all([
        csv(FORECAST_PATH).catch(()=>[]),
        csv(METRICS_PATH).catch(()=>[]),
        csv(ALERTS_PATH).catch(()=>[]),
        csv(ROI_PATH).catch(()=>[])
      ]);

      // Alerts
      const box = document.getElementById('alertsBox');
      if (!ALERTS.length){
        box.textContent = "No active alerts";
      } else {
        box.innerHTML = ALERTS.map(r =>
          ` ${r.gpu_type} · ${r.duration} · ${r.gpu_count} → $${Number(r.usd_per_gpu_hr).toFixed(2)} (vs ${Number(r.benchmark_price).toFixed(2)})`
        ).join('<br>');
      }

      // ROI table
      if (ROI.length){
        const tbl = document.getElementById('roiTable');
        let html = '<thead><tr><th>GPU</th><th>Duration</th><th>Count</th><th>Utilisation</th><th>Monthly Cost</th></tr></thead><tbody>';
        for(const r of ROI){
          html += `<tr>
            <td>${r.gpu_type}</td>
            <td>${r.duration}</td>
            <td>${r.gpu_count}</td>
            <td>${(Number(r.utilisation)*100).toFixed(0)}%</td>
            <td class="mono">$${Number(r.monthly_cost_usd).toFixed(0)}</td>
          </tr>`;
        }
        html += '</tbody>';
        tbl.innerHTML = html;
      }
    }catch(e){ console.warn("extras failed",e); }
  }

  async function main(){
    try{
      document.getElementById('lastRefresh').textContent = 'loading…';
      const [latestRows, histRows] = await Promise.all([
        csv(LATEST_PATH).catch(()=>[]),
        csv(HISTORY_PATH).catch(()=>[])
      ]);
      LATEST  = latestRows.map(coerceRow);
      HISTORY = histRows.map(coerceRow);

      // Fallback: derive latest from history
      if (!LATEST.length && HISTORY.length){
        const byKey = new Map();
        for (const r of HISTORY){
          const k = `${r.gpu_type}|${r.duration}|${r.gpu_count}`;
          const prev = byKey.get(k);
          if (!prev || String(r.ts_utc) > String(prev.ts_utc)) byKey.set(k, r);
        }
        LATEST = [...byKey.values()];
      }

      if (!LATEST.length && !HISTORY.length){
        document.getElementById('lastRefresh').textContent = 'No data found. Check docs/data/*.csv';
        return;
      }

      const gpus = uniq(LATEST.map(r=>r.gpu_type)).sort();
      const counts = uniq(LATEST.map(r=>r.gpu_count)).sort((a,b)=>a-b);
      document.getElementById('gpu').innerHTML = gpus.map(v=>`<option>${v}</option>`).join('');
      document.getElementById('duration').innerHTML = DURATIONS.map(v=>`<option>${v}</option>`).join('');
      document.getElementById('count').innerHTML = counts.map(v=>`<option>${v}</option>`).join('');

      document.getElementById('lastRefresh').textContent = 'loaded ' + new Date().toISOString().slice(0,19) + 'Z';

      updateAll();
      ['gpu','duration','count'].forEach(id => document.getElementById(id).addEventListener('change', updateAll));
      document.getElementById('showForecast').addEventListener('change', updateAll);

      // load forecasts/metrics/alerts/roi in background
      loadExtras();
    }catch(e){
      console.error(e);
      document.getElementById('lastRefresh').textContent = 'failed to load';
    }
  }

  main();
</script>
</body>
</html>

